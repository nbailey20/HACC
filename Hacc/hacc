#!/usr/bin/env python3

## Entrypoint for HACC client
## Author: Nick Bailey

import sys

try:
    from rich.live import Live
except:
    print('Python module "rich" required for HACC client. Install (pip install rich) and try again.')
    sys.exit()

from hacc_core import startup
from logger.hacc_logger import logger, LOGGER_DEBUG, LOGGER_INFO
from classes.display import Display
from input.hacc_input import parse_args, eval_args, validate_args_for_action
from input.hacc_interactive import get_input_for_end

## Main action functions
from hacc_search import search
from hacc_add import add
from hacc_delete import delete
from hacc_rotate import rotate
from hacc_install import install
from hacc_eradicate import eradicate
from hacc_backup import backup
from hacc_configure import configure
from hacc_upgrade import upgrade


HACC_VERSION = 'v0.9'



def main():
    args = parse_args()

    ## Setting logging level
    if args.debug:
        logger.setLevel(LOGGER_DEBUG)
    else:
        logger.setLevel(LOGGER_INFO)

    display = Display(client_version=HACC_VERSION)
    display.update(display_type='startup', data={})

    with Live(display.layout, screen=True):
        try:
            ## Ensure args are valid for action
            if not eval_args(display, args):
                return

            ## Initialize client for provided args
            config = startup(display, args, HACC_VERSION)
            if not config:
                display.update(display_type='end', data={})
                get_input_for_end()
                return

            
            logger.debug(f'Initial args provided: {args}')

            ## Validate input/gather any remaining args before passing to action
            valid_args = validate_args_for_action(display, args, config)
            if not valid_args:
                display.update(display_type='end', data={})
                get_input_for_end()
                return

            logger.debug(f'Validated input args: {valid_args}')

            ## Call appropriate function for action
            globals()[valid_args.action](display, valid_args, config)

            ## Wait for user response before stopping live display
            display.update(display_type='end', data={})
            get_input_for_end()
        
        ## cleanly exit without errors
        except KeyboardInterrupt:
            print('Ctrl-c received, goodbye!')



if __name__ == '__main__':
    main()